// ---------------------------------------------------------------------------------------------------
// [C++ 언어]: 연산자 오버로딩 (operator overloading) -> 기존 연산자에 새로운 연산을 정의한 후 사용  
// ---------------------------------------------------------------------------------------------------


#include <iostream>
using namespace std; 

template <typename T>
class Point
{
private:
	T x, y;
public:	
	Point(T x, T y) { this->x = x; this->y = y; }
	T ShowNumber()  { cout << "x: " << x << ", y: " << y << endl; }

//---------------------------------------------------------------------------------
	// ★★★ 중요 ★★★ 
	
	
	// 연산자 오버로딩을 활용하여 기존에 있던 "+" 연산자가 아닌, Point 객체 x, y 각각의 덧셈이 가능한 연산자를 추가
	Point operator+(Point &ref)
	// ① Point라는 클래스에서 +를 재정의(오버로딩)하겠다!  
	// ② Point &ref : Point클래스내에서 ref라는 별명으로 값을 참조하겠다!
	{
		return Point(x + ref.x, y + ref.y);
		// x + ref.x  ==  내 클래스에 있는 x + 임의의 참조자로 들어온 x
		// y + ref.y  ==  내 클래스에 있는 y + 임의의 참조자로 들어온 y 
	}
	// [ 응용 ] 
	Point operator-(Point &ref)
	{
		return Point(x - ref.x, y - ref.y);
	} 
//---------------------------------------------------------------------------------
};




int main()
{
	Point<int> P1(10, 20);
	Point<int> P2(5,2);
	
	P1.ShowNumber();
	P2.ShowNumber();

//-----------------------------------------------------------------------------
	// ★★★ 중요 ★★★ 


	// 연산자 오버로딩 "+"을 통해 객체 간의 새로운 "+" 기능이 추가됨  
	Point<int> P3 = P1 + P2;
	P3.ShowNumber(); 

	
	// 연산자 오버로딩 "-"을 통해 객체 간의 새로운 "-" 기능이 추가됨  	
	Point<int> P4 = P1 - P2;
	P4.ShowNumber(); 

//-----------------------------------------------------------------------------

	return 0;

}
